{"meta":{"title":"Inexbot NexDroid H5Project","subtitle":"开发Blog","description":"纳博特科技H5版界面开发Blog","author":"inexbot","url":"http://mintotea.gitee.io/h5project","root":"/h5project/"},"pages":[{"title":"关于项目","date":"2020-04-03T01:39:54.482Z","updated":"2020-04-03T01:39:54.482Z","comments":false,"path":"about/index.html","permalink":"http://mintotea.gitee.io/h5project/about/","excerpt":"@card{ 关于纳博特 创建机器人时代的轻松生活 纳博特成立于2014年，汇集了一批来自清华大学、东南大学、北京邮电大学、哈尔滨工业大学等国内顶尖高校的机器人团队成员和互联网行业的技术专家，致力于发展以人工智能技术和机器人技术为核心的中国智能制造技术。 纳博特在基于深度学习的人工智能控制、基于三维视觉的环境感知技术、关节型机器人动力学参数辨识、机器人高速高精度轨迹跟踪、机器人无序抓取、机器人力控打磨、机器人拖动示教等人工智能与机器人技术领域拥有核心技术与国家发明专利，发布了基于PC架构的机器人控制器产品，可用于工业机器人和CNC控制、机器视觉自动检测等机器人智能自动化系统，获得数百家客户","text":"@card{ 关于纳博特创建机器人时代的轻松生活纳博特成立于2014年，汇集了一批来自清华大学、东南大学、北京邮电大学、哈尔滨工业大学等国内顶尖高校的机器人团队成员和互联网行业的技术专家，致力于发展以人工智能技术和机器人技术为核心的中国智能制造技术。 纳博特在基于深度学习的人工智能控制、基于三维视觉的环境感知技术、关节型机器人动力学参数辨识、机器人高速高精度轨迹跟踪、机器人无序抓取、机器人力控打磨、机器人拖动示教等人工智能与机器人技术领域拥有核心技术与国家发明专利，发布了基于PC架构的机器人控制器产品，可用于工业机器人和CNC控制、机器视觉自动检测等机器人智能自动化系统，获得数百家客户的成功应用，系统综合性能达到世界领先水平，遥遥领先国内同类产品，填补国内相关行业的多项技术空白。纳博特的产品可广泛应用于弧焊焊接、电子装配、机械加工， 喷涂、码垛、切割、冲压等众多领域。 目前纳博特已经在华东，华南等多机设立服务中心,可便捷服务全国客户。 } @card{ 联系我们官方网站：www.inexbot.com 电话：025-58261986 @column-3{ @card{ 南京 联系人：单经理手机1：18068820520手机2：15895924143地址：南京市浦口区惠达路6号 北斗大厦 501 } @card{ 东莞 联系人：陈经理手机1：18068820182手机2：13544124807地址：东莞市南城区高盛科技园北区 A座 609 } @card{ 苏州 联系人：冯经理手机1：18068820506手机2：18260157967地址：江苏省张家港市杨舍镇沙洲湖科创园A1栋17楼 } } } @card{ 关于这个项目技术栈你要先学会这些才能开始进行二次开发或者继续开发：NodeJs，React，React-Router，antd, DvaJs, Electron 最少：NodeJs，React，React-Router，antd, DvaJs 其它其它的都在项目的README.md中和Blog的内容中了。 }"},{"title":"演示下载","date":"2020-04-03T06:58:12.286Z","updated":"2020-04-03T06:58:12.286Z","comments":false,"path":"demo/index.html","permalink":"http://mintotea.gitee.io/h5project/demo/","excerpt":"@card{ 解压后执行h5project.exe。 本Demo软件不含和控制器通讯的服务端，所以会显示连接失败，属于正常现象。 另，权限无密码（还没做）。 下载地址（4月3日更新） 64位Windows 32位Windows }","text":"@card{ 解压后执行h5project.exe。 本Demo软件不含和控制器通讯的服务端，所以会显示连接失败，属于正常现象。 另，权限无密码（还没做）。 下载地址（4月3日更新）64位Windows32位Windows}"},{"title":"项目进展","date":"2020-03-25T07:05:13.000Z","updated":"2020-04-03T06:27:48.112Z","comments":true,"path":"schedule/index.html","permalink":"http://mintotea.gitee.io/h5project/schedule/","excerpt":"@card{ @timeline{ 2020 @item{ 4 月 3 日 在arm64成功运行 startx 启动时要加–ignore-gpu-blacklist和–use-gl=egl参数 } @item{ 4 月 1 日 关节参数界面做好 根据机器人类型动态渲染界面 } @item{ 3 月 31 日 权限切换 根据权限切换控件的显示实现 } @item{ 3 月 30 日 机器人状态相关的API写好 } @item{ 3 月 27 日 实际控制伺服的点动做好。 } @item{ 3 月 26 日 开机流程做好 src/models/main }","text":"@card{ @timeline{ 2020@item{ 4 月 3 日在arm64成功运行startx 启动时要加–ignore-gpu-blacklist和–use-gl=egl参数 } @item{ 4 月 1 日关节参数界面做好根据机器人类型动态渲染界面 } @item{ 3 月 31 日权限切换根据权限切换控件的显示实现 } @item{ 3 月 30 日机器人状态相关的API写好 } @item{ 3 月 27 日实际控制伺服的点动做好。 } @item{ 3 月 26 日开机流程做好src/models/main } @item{ 3 月 25 日1.点动做好，在src/layout/state/jog.js;2.开机获取控制器数据的机制做好，在src/models/main.js，但是和 server 端的通讯有点问题，一次发送几条消息，有可能会有几条收不到;3.服务端接收不到消息的问题解决，服务端改用QWebsocket。 } @item{ 3 月 12 日1.Dva 和 websocket 的统一，通过 models/network 中的 subscriptions 对 websocket 进行订阅；2.通过 models/default 中的文件，给各个界面的参数默认值，通过 props 传送给界面；3.websocket 接收到 Server 端的数据后，仅需要通过 action 对 default 中的数据进行更改便可直接同步到界面。 } } 下面要做的 程序打开，解析指令，修改movj、movl、movc等指令； 几个状态查看界面。 }"},{"title":"标签检索","date":"2020-03-25T06:45:36.000Z","updated":"2020-04-03T01:39:54.484Z","comments":true,"path":"tags/index.html","permalink":"http://mintotea.gitee.io/h5project/tags/","excerpt":"","text":""}],"posts":[{"title":"从关节参数界面看如何根据机器人类型动态加载界面","slug":"从关节参数界面看如何根据机器人类型动态加载界面","date":"2020-04-02T02:09:44.000Z","updated":"2020-04-03T01:39:54.480Z","comments":true,"path":"从关节参数界面看如何根据机器人类型动态加载界面/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E4%BB%8E%E5%85%B3%E8%8A%82%E5%8F%82%E6%95%B0%E7%95%8C%E9%9D%A2%E7%9C%8B%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/","excerpt":"前提 根据机器人类型不同，其所带的轴数也不同。关节参数界面需要根据机器人的轴数来动态渲染当前界面中的轴数。 说明 使用到了 AntD 提供的 Tabs 组件来实现轴 1-轴 7 的参数展示与修改。 思路 封装 TabPane 组件 -> 通过轴的个数决定有多少个 TabPane -> 每一个 TabPane 中的空间，如输入框，它们的标签都应该与轴相关 那么基于以上，我们可以确定需要使用到 React Hooks 中的useState()和useEffect()。 更新组件 首先利用 HooksuseState() 将面板内容定义为状态。 const [tabs, setTabs]","text":"前提根据机器人类型不同，其所带的轴数也不同。关节参数界面需要根据机器人的轴数来动态渲染当前界面中的轴数。 说明使用到了 AntD 提供的 Tabs 组件来实现轴 1-轴 7 的参数展示与修改。 思路封装 TabPane 组件 -&gt; 通过轴的个数决定有多少个 TabPane -&gt; 每一个 TabPane 中的空间，如输入框，它们的标签都应该与轴相关 那么基于以上，我们可以确定需要使用到 React Hooks 中的useState()和useEffect()。 更新组件首先利用 HooksuseState() 将面板内容定义为状态。 const [tabs, setTabs] = useState([]); 在渲染函数中，直接利用{tabs}即可。 基于 Tabs 的特性，我们需要将&lt;TabPane /&gt;面板内容组件封装。 const setTab = sum =&gt; &#123; let renderTabs = []; for (let i = 1; i &lt;= sum; i++) &#123; renderTabs.push( &lt;TabPane tab=&#123;`J$&#123;i&#125;`&#125; key=&#123;i&#125;&gt; &#123;content(i)&#125; &lt;/TabPane&gt; ); &#125; setTabs(renderTabs);&#125;; 这里通过传递的sum参数，动态地将&lt;TabPane /&gt;组件 push 到renderTabs数组中，并最后使用useState()定义的setTabs()方法更新tabs状态为renderTabs。 那么每一个 TabPane 中的内容则用到了{content(i)}来将轴数传送到content()方法。 const content = joint =&gt; &#123; return ( &lt;Form&gt; &lt;Form.Item name=&#123;`joint$&#123;joint&#125;PosSWLimit`&#125; label=&#123;\"正限位\"&#125; help=&#123;\"关节参数/正限位说明\"&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; );&#125;; 那么这样一套方法已经定义好。下面就是如何根据当前机器人改变、当前机器人类型改变来自动更新状态了。 这里就用到了useEffect()。 useEffect(() =&gt; &#123; switch (props.currentRobotType) &#123; /* 六轴机器人 */ case 1: setTab(6); break; /* SCARA机器人 */ case 2: setTab(4); break; default: break; &#125; &#125;, [props.currentRobot, props.currentRobotType]); 当props.currentRobot、props.currentRobotType这些props更新时，会自动执行这个useEffect()方法，根据机器人类型不同，分别给setTab()传递不同的参数。","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"}]},{"title":"权限的实现","slug":"权限的实现","date":"2020-03-31T07:33:46.000Z","updated":"2020-04-03T01:39:54.481Z","comments":true,"path":"权限的实现/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E6%9D%83%E9%99%90%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"说明 操作权限我们当前仅仅是简单的分为“操作员”、“技术员”、“管理员”。为了区分各个权限可以做的事情，我们干脆让每个权限能看到的界面不同，看不到也就代表你不能去做。 权限当前主要影响的有上方状态栏的操作，底部界面切换按钮的操作，还有程序运行等操作。 现在完成了对底部界面切换按钮操作的控制。 实现 底部界面涉及到的文件主要有src/components/footer/index.js、src/components/paraframe/index.js，权限的切换也是在前者中实现的。 权限的切换 src/components/footer/index.js是底部栏的主要文件，我们在这里利","text":"说明操作权限我们当前仅仅是简单的分为“操作员”、“技术员”、“管理员”。为了区分各个权限可以做的事情，我们干脆让每个权限能看到的界面不同，看不到也就代表你不能去做。 权限当前主要影响的有上方状态栏的操作，底部界面切换按钮的操作，还有程序运行等操作。 现在完成了对底部界面切换按钮操作的控制。 实现底部界面涉及到的文件主要有src/components/footer/index.js、src/components/paraframe/index.js，权限的切换也是在前者中实现的。 权限的切换src/components/footer/index.js是底部栏的主要文件，我们在这里利用mapStateToProps将 models 中 App 命名空间下的 currentAuthority 状态对应到这个组件的 props 中。 const mapStateToProps = state =&gt; &#123; return &#123; currentAuthority: state.App.currentAuthority &#125;;&#125;;function Footer(props) &#123;&#125;export default connect(mapStateToProps)(Footer); 应用 AntD 的 Modal 组件实现弹出权限切换的窗口，内容使用了 AntD 的 Form 表单。利用 Modal 组件的确定按钮实现表单的提交。 const handleOk = e =&gt; &#123; form.submit();&#125;; 之后提交如果密码正确，则通过dispatch()方法将权限切换到下拉框选择的权限，并隐藏窗口。 const onFinish = values =&gt; &#123; props.dispatch(&#123; type: \"App/changeAuthority\", data: &#123; currentAuthority: values.username &#125; &#125;); setVisible(false);&#125;; 根据权限切换底部栏按钮的显示状态这里我们使用 React 的 Hooks useState()定义一个 statedisplay。 const [display, setDisplay] = useState(\"block\"); 将需要根据权限显示的按钮或其容器的 display 状态绑定为display这个 state。 &lt;!-- 变量按钮 --&gt;&lt;div style=\"&#123;&#123;display:display&#125;&#125;\"&gt; &lt;var /&gt;&lt;/div&gt; 利用 React 的 Hooks useEffect()，每次权限发生改变时自动更新 state。 useEffect(() =&gt; &#123; let authority = props.currentAuthority; if (authority === \"操作工\") &#123; setDisplay(\"none\"); &#125; else &#123; setDisplay(\"inline\"); &#125;&#125;, [props.currentAuthority]); 这样在权限为“操作工”时绑定了display的按钮或者其他控件将会隐藏，其他权限则显示。 参数窗口中的按钮动态显示的实现参数窗口就是在技术员或管理员权限下点击右下角的按钮弹出来的窗口。 这个窗口主要在src/components/paraframe/index.js文件中。 为了方便后面的维护和增加新的按钮，在 paraframe 目录下新建了paraheader.js文件，用来对界面呢中的项目进行定义，index.js文件则只需对 paraheader.js 中的内容进行遍历并显示即可。 paraheader.js这个文件暴露了一个 paraIndex 变量，其结构如下。 [ &#123; index: \"应用参数\", className: \"paraFrameApplication\", paras: [ &#123; type: \"para\", name: \"工具手参数\", link: \"/Toolhands\", authority: \"技术员\" &#125;, &#123; type: \"subIndex\", subIndex: \"远程程序\", authority: \"管理员\", paras: [ &#123; type: \"para\", name: \"IO预约\", link: \"/Remotepro\", authority: \"管理员\" &#125; ] &#125; ] &#125;]; type:分为“para”和“subIndex”，如果是 para 则为正常的参数，subIndex 则被认为是子栏目，就想远程程序子栏目一样。 name:显示的名字。 authority:能够看到这个的权限，如果设置为管理员，则技术员看不到。如果子栏目的 authority 设置为管理员，那么技术员看不到整个子栏目。 link:路由跳转的地址。 className:对应 css 中的 class。 paraframe/index.js这个里面首先用renderFrame()方法对 paraIndex 这个数组进行遍历，并根据其中的内容渲染出对应的控件。 const renderFrame = () =&gt; &#123; return paraIndex.map(value =&gt; &#123; return ( &lt;div className=&#123;value.className&#125;&gt; &lt;ul&gt; &lt;h3&gt;&#123;intl.get(value.index)&#125;&lt;/h3&gt; &#123;value.paras.map(para =&gt; &#123; if (para.type === \"para\") &#123; return ( &lt;li onClick=&#123;hideParaFrame&#125; style=&#123;&#123; display: display[para.authority] &#125;&#125; &gt; &lt;Link to=&#123;para.link&#125;&gt;&#123;intl.get(para.name)&#125;&lt;/Link&gt; &lt;/li&gt; ); &#125; else if (para.type === \"subIndex\") &#123; return ( &lt;li style=&#123;&#123; display: display[para.authority] &#125;&#125;&gt; &lt;ul&gt; &#123;intl.get(para.subIndex)&#125;&#123;\" \"&#125; &lt;img src=&#123;require(\"../../images/drop-down.png\")&#125; alt=\"\" /&gt; &#123;para.paras.map(subPara =&gt; &#123; return ( &lt;li onClick=&#123;hideParaFrame&#125; style=&#123;&#123; display: display[subPara.authority] &#125;&#125; &gt; &lt;Link to=&#123;subPara.link&#125;&gt; &#123;intl.get(subPara.name)&#125; &lt;/Link&gt; &lt;/li&gt; ); &#125;)&#125; &lt;/ul&gt; &lt;/li&gt; ); &#125; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;);&#125;; 用到 3 重遍历，先对 paraIndex 遍历，在对每一项中的 paras 进行遍历，最后对 type 为 subIndex 的项中的 paras 进行遍历,每次遍历都返回一个串 html。 使用useState()定义displaystate。 const [display, setDisplay] = useState(&#123; 操作员: \"none\", 技术员: \"block\", 管理员: \"none\"&#125;); 在遍历中对每一个按钮的容器的 display 属性进行绑定。 &lt;li onClick=&#123;hideParaFrame&#125; style=&#123;&#123; display: display[subPara.authority] &#125;&#125;&gt; &lt;Link to=&#123;subPara.link&#125;&gt;&#123;intl.get(subPara.name)&#125;&lt;/Link&gt;&lt;/li&gt; 最后还是用到useEffect()，每次props.currentAuthority发生改变时自动切换 display state。 useEffect(() =&gt; &#123; if (props.currentAuthority === \"技术员\") &#123; setDisplay(&#123; 操作员: \"block\", 技术员: \"block\", 管理员: \"none\" &#125;); &#125; else if (props.currentAuthority === \"管理员\") &#123; setDisplay(&#123; 操作员: \"block\", 技术员: \"block\", 管理员: \"block\" &#125;); &#125;&#125;, [props.currentAuthority]);","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"}]},{"title":"API-机器人状态","slug":"API-机器人状态","date":"2020-03-30T06:31:56.000Z","updated":"2020-04-03T01:39:54.479Z","comments":true,"path":"API-机器人状态/","link":"","permalink":"http://mintotea.gitee.io/h5project/API-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%8A%B6%E6%80%81/","excerpt":"机器人状态包含如下内容 * 机器人总数 * 当前的操作模式（示教/运行/远程） * 当前操作机器人 * 当前机器人类型 * 是否为多机模式 * 当前机器人伺服状态 * 是否在上电（示教模式按下 Deadman） * 当前机器人运行状态（运行模式的程序运行状态） * 当前机器人手动操作速度 * 当前机器人自动运行速度 * 当前机器人使用的用户坐标系序号 * 当前机器人使用的工具坐标系序号 * 当前机器人使用的坐标系 * 当前机器人单步运行的顺序（正序/倒叙） * 当前机器人的姿态形式（弧度/角度） * 当前机器人的位置 * 当前机器人在姿态为角度下的位置 获","text":"机器人状态包含如下内容 机器人总数 当前的操作模式（示教/运行/远程） 当前操作机器人 当前机器人类型 是否为多机模式 当前机器人伺服状态 是否在上电（示教模式按下 Deadman） 当前机器人运行状态（运行模式的程序运行状态） 当前机器人手动操作速度 当前机器人自动运行速度 当前机器人使用的用户坐标系序号 当前机器人使用的工具坐标系序号 当前机器人使用的坐标系 当前机器人单步运行的顺序（正序/倒叙） 当前机器人的姿态形式（弧度/角度） 当前机器人的位置 当前机器人在姿态为角度下的位置 获取机器人总数发送命令字: ROBOT_AMOUNT_INQUIRE数据: “” 界面获取models: robotStatus.robotAmount类型: int 当前的操作模式（示教/运行/远程）发送命令字: CURRENT_OPERATION_MODE_INQUIRE数据: “” 界面获取models: robotStatus.operaMode类型: int注释: 0-示教,1-远程,2-运行 当前操作机器人发送命令字: CURRENT_ROBOT_INQUIRE数据: “” 界面获取models: robotStatus.currentRobot类型: int注释: 无 当前机器人类型发送命令字: CURRENT_ROBOT_TYPE_INQUIRE数据:{robot:1 //机器人序号} 界面获取models: robotStatus.currentRobotType类型: int注释: 各数字对应机器人如下 R_NULL = 0, R_GENERAL_6S = 1, R_SCARA = 2, R_FOURAXIS_PALLET = 3, R_FOURAXIS = 4, R_GENERAL_1S = 5, R_GENERAL_5S = 6, R_GENERAL_6S_1 = 7, R_SCARA_TWOAXIS = 8, R_SCARA_THREEAXIS = 9, R_THREE_CARTESIAN_COORDINATE = 10, R_THREE_CARTESIAN_COORDINATE_1 = 11, R_FOUR_CARTESIAN_COORDINATE = 12, 是否为多机模式models: robotStatus.multiRobotMode类型: int注释: 0-单机模式,1-多机模式 当前机器人伺服状态发送命令字: CURRENT_ROBOT_SERVO_STATE_INQUIRE数据:{robot:1 //机器人序号} 界面获取models: robotStatus.currentRobotServoState类型: int注释: 0-停止,1-就绪,2-错误,3-运行 是否在上电（示教模式按下 Deadman）发送命令字: DEADMAN_STATUS_INQUIRE数据: “” 界面获取models: robotStatus.currentRobotServoState类型: int注释: 0-停止,1-就绪,2-错误,3-运行 当前机器人运行状态（运行模式的程序运行状态）发送命令字: CURRENT_ROBOT_RUNNING_STATE_INQUIRE数据:{robot:1 // 机器人序号} 界面获取models: robotStatus.currentRobotServoState类型: int注释: 0-停止,1-就绪,2-错误,3-运行 当前机器人手动操作速度发送命令字: CURRENT_ROBOT_SPEED_INQUIRE数据:{robot:1 // 机器人序号}注释：在示教模式获取的为手动操作速度，在其它模式获取的为运行速度。 界面获取models: robotStatus.handleSpeed类型: int注释: 数值是百分比 当前机器人自动运行速度发送命令字: CURRENT_ROBOT_SPEED_INQUIRE数据:{robot:1 // 机器人序号}注释：在示教模式获取的为手动操作速度，在其它模式获取的为运行速度。 界面获取models: robotStatus.runningSpeed类型: int注释: 数值是百分比 当前机器人使用的用户坐标系序号发送命令字: CURRENT_ROBOT_USER_INQUIRE数据:{robot:1 // 机器人序号} 界面获取models: robotStatus.currentUser类型: int注释: 1-9 是用户坐标 1-9,0 代表无用户坐标 当前机器人使用的工具坐标系序号发送命令字: CURRENT_ROBOT_TOOL_INQUIRE数据:{robot:1 // 机器人序号} 界面获取models: robotStatus.currentTool类型: int注释: 1-9 是工具坐标 1-9,0 代表无工具 当前机器人使用的坐标系发送命令字: CURRENT_ROBOT_COORD_INQUIRE数据:{robot:1 // 机器人序号} 界面获取models: robotStatus.currentCoordinate类型: int注释: 0-关节,1-直角,2-工具,3-用户 当前机器人单步运行的顺序（正序/倒叙）发送命令字: CURRENT_ROBOT_FB_INQUIRE数据: “” 界面获取models: robotStatus.currentForwardOrBackward类型: bool注释: true-倒叙,false-正序 当前机器人的姿态形式（弧度/角度）models: robotStatus.deg类型: int注释: 0-弧度,1-弧度 当前机器人的位置发送命令字: CURRENTPOS_INQUIRE数据:{“robot”:1, //1，2，3，4 表示机器人 1，2，3，4“coord”:1 //坐标模式} 界面获取models: robotStatus.pos类型: array注释: [1 轴,2 轴,3 轴,4 轴,5 轴,6 轴,7 轴]根据当前坐标系为对应的数值。 当前机器人在姿态为角度下的位置models: robotStatus.posDeg类型: array注释: [1 轴,2 轴,3 轴,4 轴,5 轴,6 轴,7 轴]根据当前坐标系为对应的数值。 设置切换当前的操作模式（示教/运行/远程）命令字: OPERATION_MODE_SET数据:{“mode”:0 //0 示教，1 远程，2 运行} 切换当前操作的机器人命令字: ROBOT_SWITCH数据:{“mode”:0, //0：单机模式，1：多机模式“robot”:1 //机器人号} 切换伺服状态命令字: SERVO_STATUS_SET数据:{robot:1, //1,2,3,4 表示机器人 1,2,3,4status:0 //0:停止，1：就绪} 示教模式上电和下电命令字: DEADMAN_STATUS_SET数据:{deadman:1 //0:伺服下电，1：伺服上电} 设置速度命令字: SPEED_SET数据:{robot:1, // 机器人号speed:50 // 速度（百分比）}注释: 在示教模式下设置，则设置的为手动速度。在其它模式设置，则设置自动运行速度。 设置用户坐标序号命令字: USERCOORDINATE_SWITCH数据:{robot:1, // 机器人号userNum:5 // 用户坐标序号,0 表示无} TOOLNUMBER_SWITCH命令字: TOOLNUMBER_SWITCH数据:{robot:1, // 机器人号curToolNum:5 // 工具序号,0 表示无} 切换坐标系命令字: TOOLNUMBER_SWITCH数据:{robot:1, //机器人号coord:0 //0 关节，1 直角，2 工具，3 用户}","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"API","slug":"API","permalink":"http://mintotea.gitee.io/h5project/tags/API/"}]},{"title":"API使用方式","slug":"API使用方式","date":"2020-03-30T05:56:21.000Z","updated":"2020-04-03T01:39:54.479Z","comments":true,"path":"API使用方式/","link":"","permalink":"http://mintotea.gitee.io/h5project/API%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"API 形式 收发数据采用 WebSocket，页面间采用 Dva(数据交互框架)，根据 Dva 的设计理念，我们将 WebSocket 使用 Dva 的 Models 进行了封装。所以界面获取数据仅需 Models 即可。 API 的展现形式 在 API 手册或文章中，我们将以以下形式描述我们的 API。 数据的发送 以改变当前使用的坐标系为例，我们会如下描写。 改变当前坐标系 命令字：\"DEADMAN_STATUS_SET\" 数据： { robot: 1, // 机器人号 coord: 0 // 坐标系，0-关节，1-直角，2-工具，3-用户 } 实际使用示例如下： im","text":"API 形式收发数据采用 WebSocket，页面间采用 Dva(数据交互框架)，根据 Dva 的设计理念，我们将 WebSocket 使用 Dva 的 Models 进行了封装。所以界面获取数据仅需 Models 即可。 API 的展现形式在 API 手册或文章中，我们将以以下形式描述我们的 API。 数据的发送以改变当前使用的坐标系为例，我们会如下描写。 改变当前坐标系命令字：&quot;DEADMAN_STATUS_SET&quot;数据：&#123;robot: 1, &#x2F;&#x2F; 机器人号coord: 0 &#x2F;&#x2F; 坐标系，0-关节，1-直角，2-工具，3-用户&#125; 实际使用示例如下： import &#123; sendMSGtoController &#125; from \"service/network\";let data = &#123; robot: 1, coord: 0&#125;;sendMSGtoController(\"DEADMAN_STATUS_SET\", data); 数据的获取以获取当前机器人总数为例，我们会如下描写。 获取机器人总数发送 命令字: ROBOT_AMOUNT_INQUIRE 数据:&quot;&quot;界面获取 models: robotStatus.robotAmount 类型：int 注释：无 实际使用示例如下： import &#123; useEffect &#125; from \"react\";import &#123; connect &#125; from \"dva\";import &#123; sendMSGtoController &#125; from \"service/network\";const mapStateToProps = state =&gt; &#123; return &#123; /* 将models中的数据对应的组件的props */ amount: state.index.robotStatus.robotAmount &#125;;&#125;;/* 界面的函数 */function Name(props) &#123; /* 使用React的Hooks,useEffect()方法,在组件加载时执行获取数据。 */ useEffect(() =&gt; &#123; /* sendMSGtoController(命令字,数据) */ sendMSGtoController(\"ROBOT_AMOUNT_INQUIRE\", \"\"); &#125;, []); return ( &lt;div&gt; &lt;p&gt;当前机器人总数为&#123;props.amount&#125;&lt;/p&gt; &lt;/div&gt; );&#125;export default connect(mapStateToProps)(Name);","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"API","slug":"API","permalink":"http://mintotea.gitee.io/h5project/tags/API/"}]},{"title":"开机流程","slug":"开机流程","date":"2020-03-26T08:58:05.000Z","updated":"2020-04-03T01:39:54.481Z","comments":true,"path":"开机流程/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E5%BC%80%E6%9C%BA%E6%B5%81%E7%A8%8B/","excerpt":"开机流程 1. 发送查询; 2. 如果服务端没有连接到控制器，则回复command:\"2b03\",data:\"unConnectedToController\"; 3. 如果服务端没有初始化完成，则回复command:\"2b03\",data:\"unInitFinish\"; 4. 如果版本不匹配，则回复command:\"2b03\",data:\"版本不匹配的字符串\"; 5. 如果初始化完成没有问题则获取数据： * 控制器 IPcommand:0x4302,data:null; * 控制器 IDcommand:0x5052,data:null; * 获取功能限制comma","text":"开机流程 发送查询; 如果服务端没有连接到控制器，则回复command:&quot;2b03&quot;,data:&quot;unConnectedToController&quot;; 如果服务端没有初始化完成，则回复command:&quot;2b03&quot;,data:&quot;unInitFinish&quot;; 如果版本不匹配，则回复command:&quot;2b03&quot;,data:&quot;版本不匹配的字符串&quot;; 如果初始化完成没有问题则获取数据： 控制器 IPcommand:0x4302,data:null; 控制器 IDcommand:0x5052,data:null; 获取功能限制command:0x2E0B,data:null; 机器人总数command:0x2E05,data:null; 当前机器人command:0x5002,data:null; 获取 IO 型号command:0x2F22,data:null; 获取 DIN 注释command:0x2F48,data:null; 获取 DOUT 注释command:0x2F4B,data:null; 获取 AIN 注释command:0x2F4E,data:null; 获取 AOUT 注释command:0x2F51,data:null; 获取到当前机器人后再获取： 获取控制模式command:0x2102,data:null; 获取当前机器人的机器人类型command:0x2E02,data:null; 获取当前机器人的伺服状态command:0x2002,data:{robot:currentRobot}; 获取当前机器人的运行状态command:0x3D02,data:{robot:currentRobot}; 获取当前机器人的速度command:0x2602,data:{robot:currentRobot}; 获取当前机器人的用户坐标command:0x3C0B,data:{robot:currentRobot}; 获取当前机器人的工具坐标command:0x380B,data:{robot:currentRobot}; 获取当前机器人的坐标系command:0x2202,data:{robot:currentRobot}; 获取当前机器人的正反向command:0x2405,data:null; 获取当前机器人的编码器低压吗？command:0x3305,data:{robot:currentRobot}; 解析开机流程主要涉及到了 2 个文件，src/service/commandlist.js、src/model/main.js。 对于src/model/main.js，我们主要用到了sendCheckServerState()、receiveCheckServerState(state)、sendCheckCurrentRobotState(currentRobot)三个函数。以及下面的subsriptions中的Websocket()方法。 sendCheckServerState()这个函数在subscriptrions中的onOpen()方法中当连接成功便调用。 这个函数只有 function sendCheckServerState() &#123; sendMSGtoServer(\"CheckState\", \"\");&#125; 用来获取控制器的初始化信息，控制器会回复命令字为2b03的消息，根据其中的data来判断是否初始化成功。若成功，data为initFinish，否则为unInitFinish，将结果传给receiveCheckServerState(state)函数 receiveCheckServerState(state)function receiveCheckServerState(state) &#123; /* 如果已经初始化完成，则往下执行 */ if (state === true) &#123; showMessage.destroy(); showMessage.loading(\"服务端初始化完成\"); sendMSGtoController(\"CONTROLLER_IP_INQUIRE\", \"\"); sendMSGtoController(\"CONTROLLER_ID_INQUIRE\", \"\"); sendMSGtoController(\"ROBOT_ENCRYPT_INQUIRE\", \"\"); sendMSGtoController(\"ROBOT_AMOUNT_INQUIRE\", \"\"); sendMSGtoController(\"CURRENT_ROBOT_INQUIRE\", \"\"); sendMSGtoController(\"IO_CONFIG_INQUIRE\", \"\"); sendMSGtoController(\"DIN_NAME_INQUIRE\", \"\"); sendMSGtoController(\"DOUT_NAME_INQUIRE\", \"\"); sendMSGtoController(\"AIN_NAME_INQUIRE\", \"\"); sendMSGtoController(\"AOUT_NAME_INQUIRE\", \"\"); &#125; else if (state === false) &#123; /* 如果没有初始化完成，则1秒后重新查询 */ showMessage.destroy(); showMessage.loading(\"正在等待服务端初始化\"); setTimeout(() =&gt; &#123; sendCheckServerState(); &#125;, Setting.inquireFailedRetryTime); &#125;&#125; state 用来接收初始化结果，false失败，则回到sendCheckServerState()。成功，则用sendMSGtoController(command,data)方法，发送获取数据的信息。 接收信息则用subscriptions中的Websocket()方法自动接收并根据命令字自动将收到的data存入相应的状态。 例子-获取控制器 IP使用sendMSGtoController(&quot;CONTROLLER_IP_INQUIRE&quot;, &quot;&quot;);发送给控制器获取 IP 的消息后，控制器会自动回复消息。命令字为4303，获取消息在Websocket()方法中自动接收。 Websocket(&#123; dispatch &#125;) &#123;.....switch(command)&#123; case\"4303\": dispatch(&#123; type: \"receiveControllerIP\", data: dataString &#125;); break;&#125;.....&#125; dispatch()方法将命令字4303将下面reducers中的receiveControllerIP(state,action)联系起来，并将获取到的数据dataString传送到receiveControllerIP(state,action)的action。 reducers&#123;receiveControllerIP(state, action) &#123; let _state = JSON.parse(JSON.stringify(state)); _state.controllerConfig.num = action.data.num; _state.controllerConfig.network = action.data.network; return _state; &#125;&#125; 控制器传来的数据为 data:&#123;network: [ &#123; address: \"\", dns: \"\", gateway: \"\", name: \"\" &#125;, &#123; address: \"\", dns: \"\", gateway: \"\", name: \"\" &#125; ],num: 2&#125; 回到receiveControllerIP()，先将state赋值给_state，因为 dva 不允许对state进行直接操作。然后将接收到的data中的num赋值给_state中的controllerConfig中的num。其中controllerConfig的定义在src/models/default/controllerconfig.js中。将将接收到的data中的network赋值给_state中的controllerConfig中的network。 返回_state，状态赋值完毕。 receiveCurrentRobot()src/models/main.js中reducers的receiveCurrentRobot()方法，用来对接收到当前机器人后进行处理。 receiveCurrentRobot(state, action) &#123; let _state = JSON.parse(JSON.stringify(state)); _state.robotStatus.currentRobot = action.data.robot; _state.robotStatus.operaMode = action.data.mode; sendCheckCurrentRobotState(_state.robotStatus.currentRobot); return _state;&#125; 首先将数据存入状态中，然后执行sendCheckCurrentRobotState(_state.robotStatus.currentRobot)。 sendCheckCurrentRobotState(currentRobot)接收到当前机器人后，便要获取当前机器人的相关信息。 function sendCheckCurrentRobotState(robot) &#123; let curRobot = &#123; robot: robot &#125;; sendMSGtoController(\"CURRENT_ROBOT_TYPE_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_SERVO_STATE_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_RUNNING_STATE_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_SPEED_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_USER_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_TOOL_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_COORD_INQUIRE\", curRobot); sendMSGtoController(\"CURRENT_ROBOT_FB_INQUIRE\", \"\"); sendMSGtoController(\"CURRENT_ROBOT_ENCODER_STATE_INQUIRE\", curRobot);&#125; 接收到的数据依然通过subsriptions进行处理。","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"数据收发","slug":"数据收发","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/"},{"name":"控制器数据获取","slug":"控制器数据获取","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"}]},{"title":"点动的实现","slug":"点动的实现","date":"2020-03-25T02:49:13.000Z","updated":"2020-04-03T01:39:54.481Z","comments":true,"path":"点动的实现/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E7%82%B9%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"文件 在src/layout/state/jog.js中做了点动的机制。 代码 对 Button 的处理 对于“-”（反向）和“+”（正向）的 Button 控件，里面引入了 3 个方法，分别是onMouseDown、onMouseUp、onMouseLeave，例如对于 1 轴（4 个坐标系下），我们的代码如下： /* {axis[0]}用来通过当前坐标系来获取当前1轴的名称 * 在关节、直角、工具、用户坐标系下分别为J1、X、TX、UX */ {axis[0]}","text":"文件在src/layout/state/jog.js中做了点动的机制。 代码对 Button 的处理对于“-”（反向）和“+”（正向）的 Button 控件，里面引入了 3 个方法，分别是onMouseDown、onMouseUp、onMouseLeave，例如对于 1 轴（4 个坐标系下），我们的代码如下： /* &#123;axis[0]&#125;用来通过当前坐标系来获取当前1轴的名称 *在关节、直角、工具、用户坐标系下分别为J1、X、TX、UX */&lt;h3&gt;&#123;axis[0]&#125;&lt;/h3&gt;&lt;button onMouseDown=&#123;handleOnMouseDown.bind(this,1,-1)&#125; onMouseUp=&#123;handleOnMouseUp.bind(this,1)&#125; onMouseLeave=&#123;handleOnMouseUp.bind(this,1)&#125;&gt; -&lt;/button&gt;&lt;Form.Item name=\"axis1\"&gt; &lt;input disabled=\"&#123;true&#125;\" /&gt;&lt;/Form.Item&gt;&lt;button onMouseDown=&#123;handleOnMouseDown.bind(this,1,1)&#125; onMouseUp=&#123;handleOnMouseUp.bind(this,1)&#125; onMouseLeave=&#123;handleOnMouseUp.bind(this,1)&#125;&gt; +&lt;/button&gt; onMouseDown方法是对鼠标（或触摸屏）按下后的处理； onMouseUp方法是对鼠标（或触摸屏）抬起来的处理； 引入onMouseLeave方法是防止按下后移出按钮再抬起，会导致onMouseUp方法不会触发所做的应对机制。 函数onMouseDown指向了handleMouseDown函数，要注意的是，使用需要传参的回调函数不能用handleMouseDown(xx,yy)这样的形式，而是需要使用handleMouseDown.bind(this,xx,yy)这样的形式。 首先需要在函数外定义一个变量如initTime，用来对setInterval进行有指向性的开启和关闭。 let initTime handleMouseDown这个函数用来对按下“-”或者“+”按钮后的处理。 function handleOnMouseDown(axis, direction) &#123; let jogData = &#123; axis: axis, direction: direction &#125;; initTime = setInterval(() =&gt; &#123; sendMSGtoController(\"JOG_OPERATION_MOVE\", jogData); &#125;, 100);&#125; 使用let jogData来组成需要发送给控制器的数据，这个根据控制器的通讯协议可以查到; 使用setInterval()来开启定时器，由于我们后面要有指向性的关闭这个定时器，所以需要用到之前定义的变量initTime = setInterval(code,time); 在定时器中使用src/service/network.js中的sendMSGtoController(command,data)方法来发送数据给定时器，间隔时间设置为 100ms; &quot;JOG_OPERATION_MOVE&quot;这个命令字在src\\service\\commandlist.js定义好。 handleMouseUp这个函数用来对停止点动进行处理。 function handleOnMouseUp(axis) &#123; let stopJog = &#123; axis: axis &#125;; clearInterval(initTime); sendMSGtoController(\"JOG_OPERATION_STOP\", stopJog);&#125; 使用let stopJog定义停止点动需要给控制器发送的数据，这个根据控制器的通讯协议可以查到; 使用clearInterval(initTime)来对之前initTime = setInterval(code,time)开启的定时器进行指向性关闭; 然后使用sendMSGtoController(command,data)将停止点动发送给控制器; &quot;JOG_OPERATION_STOP&quot;这个命令字在src\\service\\commandlist.js定义好。","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"数据收发","slug":"数据收发","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/"},{"name":"点动","slug":"点动","permalink":"http://mintotea.gitee.io/h5project/tags/%E7%82%B9%E5%8A%A8/"}]},{"title":"实现多语言","slug":"实现多语言","date":"2020-03-13T05:42:20.000Z","updated":"2020-04-03T01:39:54.481Z","comments":true,"path":"实现多语言/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%AD%E8%A8%80/","excerpt":"利用 react-intl-universal 实现国际化 对所有文本实现多语言，我们引用 react-intl-universal。 实现方式 引入 intl 对象 在组件中通过import intl from \"react-intl-universal\"引入 intl 对象 intl 提供了intl.get()方法，以下为几个场景下的使用示例。 在 HTML 代码中 在 HTML 代码中引用，需要用{}将intl.get(\"String\")包含起来 {intl.get(\"程序\")}","text":"利用 react-intl-universal 实现国际化对所有文本实现多语言，我们引用 react-intl-universal。 实现方式引入 intl 对象在组件中通过import intl from &quot;react-intl-universal&quot;引入 intl 对象 intl 提供了intl.get()方法，以下为几个场景下的使用示例。 在 HTML 代码中在 HTML 代码中引用，需要用{}将intl.get(&quot;String&quot;)包含起来 &lt;Button icon=&#123;&lt;LegacyIcon type=\"container\" /&gt;&#125;&gt;&#123;intl.get(\"程序\")&#125;&lt;/Button&gt; 在函数中在函数中引用直接调用intl.get()方法 const quesUp = () =&gt; &#123; if (isDisabled === true) setButton2State(&#123; buttoncharacter: intl.get(\"关闭\"), buttontype: \"dashed\" &#125;); else setButton2State(&#123; buttoncharacter: intl.get(\"问题\"), buttontype: \"default\" &#125;);&#125;; 翻译文件多语言文件保存在 locales 文件夹中，zh-CN.json 和 en-US.json 分别对应中、英文文本。 以“保存”这个字符串为例，在两个文件中保存方式如下 中文（zh-CN.json） &#123; \"保存\": \"保存\"&#125; 英文（en-US.json） &#123; \"保存\": \"Save\"&#125; 若文本在翻译文件中没有写入，则会显示为空 翻译规则 json 文件中的节点名原则上使用中文 固定词汇使用词汇来作为节点名 如果是长文本，则用界面/位置作为节点名，在intl.get()方法中使用使用”界面/位置”作为包含字符串 如何加入新语言 在 locales 文件夹中加入新的.json 文件 在 layout/pages/welcome.js 和 layout/pages/system/language.js 中的语言下拉框中加入新的&lt;Option value=&quot;json文件名&quot;&gt;语言&lt;/Optionn&gt;","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"国际化","slug":"国际化","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"}]},{"title":"界面获取数据方式","slug":"界面获取数据方式","date":"2020-03-12T09:05:42.000Z","updated":"2020-04-03T01:39:54.482Z","comments":true,"path":"界面获取数据方式/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E7%95%8C%E9%9D%A2%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F/","excerpt":"方法 界面获取控制器参数需要通过 Dva 提供的connect方法，将组件（界面）与 models 中的 state 连接起来。 例子 以 Dh 参数界面(/src/layout/pages/robotpara/dhpara)为例 models models/main.js 中 dh 参数相关的代码如下： 命名空间为 index，所以在引用时用 index namespace: \"index\"; state保存 models 中的参数，robotParameter由 models/default/robotparameter.js 导出，在 main.js 中通过import引用","text":"方法界面获取控制器参数需要通过 Dva 提供的connect方法，将组件（界面）与 models 中的 state 连接起来。 例子以 Dh 参数界面(/src/layout/pages/robotpara/dhpara)为例 modelsmodels/main.js 中 dh 参数相关的代码如下： 命名空间为 index，所以在引用时用 index namespace: \"index\"; state保存 models 中的参数，robotParameter由 models/default/robotparameter.js 导出，在 main.js 中通过import引用 /* dh参数的参数保存在robotParameter的dh参数键内 */state: &#123; robotParameter;&#125; 通过subscriptions对 websocket 的消息进行订阅，接收到消息后通过命令字command进行分类处理。 这里接收到command === &quot;3a03&quot;后，判断到是接收 dh 参数，于是通过dispatch()方法，将dataString数据传递给下面的receiveDhPara这个 reducer subscriptions: &#123; /* 以下代码不涉及参数********** */ Websocket(&#123; dispatch &#125;) &#123; var data = \"\"; ws.onmessage = async message =&gt; &#123; console.log(message); data = await comeMessage(message); if (data === \"unConnectedToController\") &#123; notification.error(&#123; message: intl.get(\"unConnectedToController\"), description: intl.get(\"unConnectedToServer\"), duration: 0 &#125;); return; &#125; let command = data[0]; let dataString = JSON.parse(data[1]); /* *************************** */ /* 接收到命令字14851，于是做处理，将接收到的数据传送给下面的receiveDhPara这个reducer */ switch (command) &#123; case \"3a03\": dispatch(&#123; type: \"receiveDhPara\", data: dataString &#125;); break; /* 以下代码不涉及参数**************** */ default: showMessage.error(\"接收到错误信息\"); console.error( `数据格式异常。\\n 完整信息：$&#123;message&#125; \\n 命令字：$&#123;command&#125; \\n 数据：$&#123;dataString&#125;` ); /* **************************** */ &#125; &#125;; &#125;&#125; reducers是对dispatch()方法的参数进行处理的方法集合。 这里的receiveDhPara()用来将接收到的 dh 参数传递到 state 中的 robotParameter 内的 dhPara 内。 reducers: &#123; /* 将接收到的数据写入dh参数中 */ receiveDhPara(state, action) &#123; let _state = JSON.parse(JSON.stringify(state)); _state.robotParameter.dhPara = action.data; return _state; &#125;&#125; robotparameter.js 的关于 dh 参数的代码如下 dhPara: &#123; Link: [ &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125;, &#123; a: 1, b: 2, c: 3, d: 4, theta: 5 &#125; ], CoupleCoe: &#123; Couple_Coe_1_2: 1, Couple_Coe_2_3: 2, Couple_Coe_3_2: 3, Couple_Coe_3_4: 3, Couple_Coe_4_5: 3, Couple_Coe_4_6: 3, Couple_Coe_5_6: 3 &#125;, upsideDown: true &#125; 界面dh 参数界面的代码如下 先使用 mapStateToProps 函数将 models/main.js 中的 robotParameter(存于 models/default/robotparameter.js 中)的 dhPara 对应到 props.dhPara import &#123; connect &#125; from \"dva\";const mapStateToProps = state =&gt; &#123; return &#123; dhPara: state.index.robotParameter.dhPara &#125;;&#125;;/* 定义Dhpara也就是DH参数界面（组件） */ 进入界面获取一遍 dh 参数，使用useEffect()，在 props.dhPara 参数发生改变时自动执行form.setFieldsValue()方法，将 props.dhPara 中的参数填入表单 useEffect(() =&gt; &#123; form.setFieldsValue(&#123; /* 将props.dhPara中各个参数对应到界面控件所需要的L1~L7以及耦合比 */ L1: props.dhPara.Link[0].d, L2: props.dhPara.Link[1].a, L3: props.dhPara.Link[2].a, L4: props.dhPara.Link[3].d, L5: props.dhPara.Link[5].d, L6: props.dhPara.Link[0].a, L7: props.dhPara.Link[2].d, five: props.dhPara.Link[4].theta, Couple_Coe_1_2: props.dhPara.CoupleCoe.Couple_Coe_1_2, Couple_Coe_2_3: props.dhPara.CoupleCoe.Couple_Coe_2_3, Couple_Coe_3_2: props.dhPara.CoupleCoe.Couple_Coe_3_2, Couple_Coe_3_4: props.dhPara.CoupleCoe.Couple_Coe_3_4, Couple_Coe_4_5: props.dhPara.CoupleCoe.Couple_Coe_4_5, Couple_Coe_4_6: props.dhPara.CoupleCoe.Couple_Coe_4_6, Couple_Coe_5_6: props.dhPara.CoupleCoe.Couple_Coe_5_6, upsideDown: props.dhPara.upsideDown, preRobot: \"Customize\" &#125;);&#125;, [props.dhPara]); 定义表单验证成功后的方法，先将表单中的数据组成字符串，然后使用sendMSGtoController()方法将参数经由服务端发送到控制器。 const onFinish = values =&gt; &#123; let dhPara = &#123; upsideDown: values.upsideDown, /* 字符串转换为数字后发给控制器，用parseFloat 也是将form.setFieldsValue中反过来 */ Link: [ &#123; a: parseFloat(values.L6), d: parseFloat(values.L1) &#125;, &#123; a: parseFloat(values.L2), d: parseFloat(values.L7) &#125;, &#123; a: parseFloat(values.L3) &#125;, &#123; d: parseFloat(values.L4) &#125;, &#123; theta: parseFloat(values.five) &#125;, &#123; d: parseFloat(values.L5) &#125; ], CoupleCoe: &#123; Couple_Coe_1_2: parseFloat(values.Couple_Coe_1_2), Couple_Coe_2_3: parseFloat(values.Couple_Coe_2_3), Couple_Coe_3_2: parseFloat(values.Couple_Coe_3_2), Couple_Coe_3_4: parseFloat(values.Couple_Coe_3_4), Couple_Coe_4_5: parseFloat(values.Couple_Coe_4_5), Couple_Coe_4_6: parseFloat(values.Couple_Coe_4_6), Couple_Coe_5_6: parseFloat(values.Couple_Coe_5_6) &#125; &#125;; /* 通过sendMSGtoController()方法发送数据 */ sendMSGtoController(\"DHPARAMETER_SET\", dhPara);/* 通过connect方法将mapStateToProps和Dhpara连接起来 */ 使用connect()方法将mapStateToProps()和Dhpara组件连接起来，这样 Dhpara 组件就能接收 models 中的参数。 export default connect(mapStateToProps)(Dhpara);","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"数据收发","slug":"数据收发","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/"},{"name":"参数","slug":"参数","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%8F%82%E6%95%B0/"}]},{"title":"如何在这里写新博客","slug":"如何在这里写新博客","date":"2020-02-10T05:58:03.000Z","updated":"2020-04-03T01:39:54.480Z","comments":true,"path":"如何在这里写新博客/","link":"","permalink":"http://mintotea.gitee.io/h5project/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%99%E9%87%8C%E5%86%99%E6%96%B0%E5%8D%9A%E5%AE%A2/","excerpt":"下载依赖 首先在终端中执行以下指令 yarn:yarn npm:npm i cnpm:cnpm i 创建新文档 在document目录下执行指令hexo new 文档名 创建的文档在document/source/_posts目录下。 使用 Markdown 书写 使用 Markdown 书写请遵循 Markdown 语法，可以先参考目录中的其它文章。 简书网教程：献给写作者的 Markdown 新手指南 菜鸟教程：Markdown 教程 在本地预览 1. 执行 npm 脚本中document/package.json中的server项; 2. 在浏览器中打开localh","text":"下载依赖首先在终端中执行以下指令 yarn:yarn npm:npm i cnpm:cnpm i 创建新文档在document目录下执行指令hexo new 文档名 创建的文档在document/source/_posts目录下。 使用 Markdown 书写使用 Markdown 书写请遵循 Markdown 语法，可以先参考目录中的其它文章。 简书网教程：献给写作者的 Markdown 新手指南 菜鸟教程：Markdown 教程 在本地预览 执行 npm 脚本中document/package.json中的server项; 在浏览器中打开localhost:4000，修改文档后刷新页面即更新。 push 到码云 执行 npm 脚本中document/package.json中的build项; 提交并推送代码; 到Gitee Pages更新。","categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"其它","slug":"其它","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%85%B6%E5%AE%83/"}]}],"categories":[],"tags":[{"name":"说明","slug":"说明","permalink":"http://mintotea.gitee.io/h5project/tags/%E8%AF%B4%E6%98%8E/"},{"name":"二次开发","slug":"二次开发","permalink":"http://mintotea.gitee.io/h5project/tags/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"},{"name":"API","slug":"API","permalink":"http://mintotea.gitee.io/h5project/tags/API/"},{"name":"数据收发","slug":"数据收发","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/"},{"name":"控制器数据获取","slug":"控制器数据获取","permalink":"http://mintotea.gitee.io/h5project/tags/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"name":"点动","slug":"点动","permalink":"http://mintotea.gitee.io/h5project/tags/%E7%82%B9%E5%8A%A8/"},{"name":"国际化","slug":"国际化","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"参数","slug":"参数","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%8F%82%E6%95%B0/"},{"name":"其它","slug":"其它","permalink":"http://mintotea.gitee.io/h5project/tags/%E5%85%B6%E5%AE%83/"}]}